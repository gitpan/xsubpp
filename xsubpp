#!./miniperl

=head1 NAME

xsubpp - compiler to convert Perl XS code into C code

=head1 SYNOPSIS

B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-typemap typemap>]... file.xs

=head1 DESCRIPTION

I<xsubpp> will compile XS code into C code by embedding the constructs
necessary to let C functions manipulate Perl values and creates the glue
necessary to let Perl access those functions.  The compiler uses typemaps to
determine how to map C function parameters and variables to Perl values.

The compiler will search for typemap files called I<typemap>.  It will use
the following search path to find default typemaps, with the rightmost
typemap taking precedence.

	../../../typemap:../../typemap:../typemap:typemap

=head1 OPTIONS

=over 5

=item B<-C++>

Adds ``extern "C"'' to the C code.


=item B<-except>

Adds exception handling stubs to the C code.

=item B<-typemap typemap>

Indicates that a user-supplied typemap should take precedence over the
default typemaps.  This option may be used multiple times, with the last
typemap having the highest precedence.

=item B<-v>

Prints the I<xsubpp> version number to standard output, then exits.

=back

=head1 ENVIRONMENT

No environment variables are used.

=head1 AUTHOR

Larry Wall

=head1 MODIFICATION HISTORY

See the file F<changes.pod>.

=head1 SEE ALSO

perl(1), perlapi(1)

=cut

# Global Constants
$XSUBPP_version = "1.922";
require 5.001;

$usage = "Usage: xsubpp [-v] [-C++] [-except] [-s pattern] [-typemap typemap]... file.xs\n";

$except = "";
SWITCH: while (@ARGV and $ARGV[0] =~ /^-./) {
    $flag = shift @ARGV;
    $flag =~ s/^-// ;
    $spat = shift,	next SWITCH	if $flag eq 's';
    $cplusplus = 1,	next SWITCH	if $flag eq 'C++';
    $except = " TRY",	next SWITCH	if $flag eq 'except';
    push(@tm,shift),	next SWITCH	if $flag eq 'typemap';
    (print "xsubpp version $XSUBPP_version\n"), exit  	
	if $flag eq 'v';
    die $usage;
}
@ARGV == 1 or die $usage;
chomp($pwd = `pwd`);
# Check for error message from VMS
if ($pwd =~ /unrecognized command verb/) { $Is_VMS = 1; $pwd = $ENV{DEFAULT} }
($dir, $filename) = $ARGV[0] =~ m#(.*)/(.*)#
	or ($dir, $filename) = $ARGV[0] =~ m#(.*[>\]])(.*)#
	or ($dir, $filename) = ('.', $ARGV[0]);
chdir($dir);

sub TrimWhitespace
{
    $_[0] =~ s/^\s+|\s+$//go ;
}

sub TidyType
{
    local ($_) = @_ ;

    # rationalise any '*' by joining them into bunches and removing whitespace
    s#\s*(\*+)\s*#$1#g;
    s#(\*+)# $1 #g ;

    # change multiple whitespace into a single space
    s/\s+/ /g ;
    
    # trim leading & trailing whitespace
    TrimWhitespace($_) ;

    $_ ;
}

$typemap = shift @ARGV;
foreach $typemap (@tm) {
    die "Can't find $typemap in $pwd\n" unless -r $typemap;
}
unshift @tm, qw(../../../../lib/ExtUtils/typemap ../../../lib/ExtUtils/typemap
                ../../lib/ExtUtils/typemap ../../../typemap ../../typemap
                ../typemap typemap);
foreach $typemap (@tm) {
    next unless -e $typemap ;
    # skip directories, binary files etc.
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next 
	unless -T $typemap ;
    open(TYPEMAP, $typemap) 
	or warn ("Warning: could not open typemap file '$typemap': $!\n"), next;
    $mode = 'Typemap';
    $junk = "" ;
    $current = \$junk;
    while (<TYPEMAP>) {
	next if /^\s*#/;
	if (/^INPUT\s*$/)   { $mode = 'Input';   $current = \$junk;  next; }
	if (/^OUTPUT\s*$/)  { $mode = 'Output';  $current = \$junk;  next; }
	if (/^TYPEMAP\s*$/) { $mode = 'Typemap'; $current = \$junk;  next; }
	if ($mode eq 'Typemap') {
	    chomp;
	    my $line = $_ ;
            TrimWhitespace($_) ;
	    # skip blank lines and comment lines
	    next if /^$/ or /^#/ ;
	    my($type,$kind) = /^\s*(.*?\S)\s+(\S+)\s*$/ or
		warn("Warning: File '$typemap' Line $. '$line' TYPEMAP entry needs 2 columns\n"), next;
	    $type_kind{TidyType($type)} = $kind ;
	}
	elsif (/^\s/) {
	    $$current .= $_;
	}
	elsif ($mode eq 'Input') {
	    s/\s+$//;
	    $input_expr{$_} = '';
	    $current = \$input_expr{$_};
	}
	else {
	    s/\s+$//;
	    $output_expr{$_} = '';
	    $current = \$output_expr{$_};
	}
    }
    close(TYPEMAP);
}

foreach $key (keys %input_expr) {
    $input_expr{$key} =~ s/\n+$//;
}

$END = "!End!\n\n";		# "impossible" keyword (multiple newline)

# Match an XS keyword
$BLOCK_re= "\\s*(REQUIRE|BOOT|CASE|PREINIT|INPUT|INIT|CODE|PPCODE|OUTPUT|CLEANUP|ALIAS|$END)\\s*:";

# Input:  ($_, @line) == unparsed input.
# Output: ($_, @line) == (rest of line, following lines).
# Return: the matched keyword if found, otherwise 0
sub check_keyword {
	$_ = shift(@line) while !/\S/ && @line;
	s/^(\s*)($_[0])\s*:\s*(?:#.*)?/$1/s && $2;
}


sub print_section {
    $_ = shift(@line) while !/\S/ && @line;
    for (;  defined($_) && !/^$BLOCK_re/o;  $_ = shift(@line)) {
	print "$_\n";
    }
}

sub CASE_handler {
    blurt ("Error: `CASE:' after unconditional `CASE:'")
	if $condnum && $cond eq '';
    $cond = $_;
    TrimWhitespace($cond);
    print "   ", ($condnum++ ? " else" : ""), ($cond ? " if ($cond)\n" : "\n");
    $_ = '' ;
}

sub INPUT_handler {
    for (;  !/^$BLOCK_re/o;  $_ = shift(@line)) {
	last if /^\s*NOT_IMPLEMENTED_YET/;
	next unless /\S/;	# skip blank lines 

	TrimWhitespace($_) ;
	my $line = $_ ;

	# remove trailing semicolon if no initialisation
	s/\s*;$//g unless /=/ ;

	# check for optional initialisation code
	my $var_init = '' ;
	$var_init = $1 if s/\s*(=.*)$//s ;
	$var_init =~ s/"/\\"/g;

	s/\s+/ /g;
	my ($var_type, $var_addr, $var_name) = /^(.*?[^& ]) *(\&?) *\b(\w+)$/s
	    or blurt("Error: invalid argument declaration '$line'"), next;

	# Check for duplicate definitions
	blurt ("Error: duplicate definition of argument '$var_name' ignored"), next
	    if $arg_list{$var_name} ++  ;

	$thisdone |= $var_name eq "THIS";
	$retvaldone |= $var_name eq "RETVAL";
	$var_types{$var_name} = $var_type;
	print "\t" . &map_type($var_type);
	$var_num = $args_match{$var_name};
	if ($var_addr) {
	    $var_addr{$var_name} = 1;
	    $func_args =~ s/\b($var_name)\b/&$1/;
	}
	if ($var_init =~ /^=\s*NO_INIT\s*;?\s*$/) {
	    print "\t$var_name;\n";
	} elsif ($var_init =~ /\S/) {
	    &output_init($var_type, $var_num, "$var_name $var_init");
	} elsif ($var_num) {
	    # generate initialization code
	    &generate_init($var_type, $var_num, $var_name);
	} else {
	    print ";\n";
	}
    }
}

sub OUTPUT_handler {
    for (;  !/^$BLOCK_re/o;  $_ = shift(@line)) {
	next unless /\S/;
	my ($outarg, $outcode) = /^\s*(\S+)\s*(.*?)\s*$/s ;
	blurt ("Error: duplicate OUTPUT argument '$outarg' ignored"), next
	    if $outargs{$outarg} ++ ;
	if (!$gotRETVAL and $outarg eq 'RETVAL') {
	    # deal with RETVAL last
	    $RETVAL_code = $outcode ;
	    $gotRETVAL = 1 ;
	    next ;
	}
	blurt ("Error: OUTPUT $outarg not an argument"), next
	    unless defined($args_match{$outarg});
	blurt("Error: No input definition for OUTPUT argument '$outarg' - ignored"), next
	    unless defined $var_types{$outarg} ;
	if ($outcode) {
	    print "\t$outcode\n";
	} else {
	    $var_num = $args_match{$outarg};
	    &generate_output($var_types{$outarg}, $var_num, $outarg); 
	}
    }
}

sub GetAliases
{
    my ($line) = @_ ;
    my ($orig) = $line ;
    my ($alias) ;
    my ($value) ;

    # Parse alias definitions
    # format is
    #    alias = value alias = value ...

    while ($line =~ s/^\s*([\w:]+)\s*=\s*(\w+)\s*//) {
        $alias = $1 ;
        $orig_alias = $alias ;
        $value = $2 ;

        # check for optional package definition in the alias
	$alias = $Packprefix . $alias if $alias !~ /::/ ;
        
        # check for duplicate alias name & duplicate value
	Warn("Warning: Ignoring duplicate alias '$orig_alias'")
	    if defined $XsubAliases{$pname}{$alias} ;

        Warn("Warning: Aliases '$orig_alias' and '$XsubAliasValues{$pname}{$value}' have identical values")
	    if $XsubAliasValues{$pname}{$value} ;

        $XsubAliases{$pname}{$alias} = $value ;
        $XsubAliasValues{$pname}{$value} = $orig_alias ;
    }

    blurt("Error: Cannot parse ALIAS definitions from '$orig'")
        if $line ;
}

sub ALIAS_handler
{
    for (;  !/^$BLOCK_re/o;  $_ = shift(@line)) {
	next unless /\S/;
	TrimWhitespace($_) ;
        GetAliases($_) if $_ ;
    }
}

sub REQUIRE_handler
{
    # the rest of the current line should contain a version number
    my ($Ver) = $_ ;

    TrimWhitespace($Ver) ;

    death ("Error: REQUIRE expects a version number")
	unless $Ver ;

    # check that the version number is of the form n.n
    death ("Error: REQUIRE: expected a number, got '$Ver'")
	unless $Ver =~ /^\d+(\.\d*)?/ ;

    death ("Error: xsubpp $Ver (or better) required--this is only $XSUBPP_version.")
        unless $XSUBPP_version >= $Ver ; 
}

sub check_cpp {
    my @cpp = grep(/^\#\s*(?:if|e\w+)/, @line);
    if (@cpp) {
	my ($cpp, $cpplevel);
	for $cpp (@cpp) {
	    if ($cpp =~ /^\#\s*if/) {
		$cpplevel++;
	    } elsif (!$cpplevel) {
		Warn("Warning: #else/elif/endif without #if in this function");
		return;
	    } elsif ($cpp =~ /^\#\s*endif/) {
		$cpplevel--;
	    }
	}
	Warn("Warning: #if without #endif in this function") if $cpplevel;
    }
}


sub Q {
    my($text) = @_;
    $text =~ tr/#//d;
    $text =~ s/\[\[/{/g;
    $text =~ s/\]\]/}/g;
    $text;
}

open(F, $filename) or die "cannot open $filename: $!\n";

# Identify the version of xsubpp used
print <<EOM ;
/*
 * This file was generated automatically by xsubpp version $XSUBPP_version from the 
 * contents of $filename. Don't edit this file, edit $filename instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

EOM
 

while (<F>) {
    last if ($Module, $Package, $Prefix) =
	/^MODULE\s*=\s*([\w:]+)(?:\s+PACKAGE\s*=\s*([\w:]+))?(?:\s+PREFIX\s*=\s*(\S+))?\s*$/;
    print $_;
}
&Exit unless defined $_;

my $lastline	= $_;
my $lastline_no = $.;


# Read next xsub into @line from ($lastline, <F>).
sub fetch_para {
    # parse paragraph
    @line = ();
    @line_no = () ;
    return 0 unless defined $lastline;

    if ($lastline =~
	/^MODULE\s*=\s*([\w:]+)(?:\s+PACKAGE\s*=\s*([\w:]+))?(?:\s+PREFIX\s*=\s*(\S+))?\s*$/) {
	$Module = $1;
	$Package = defined($2) ? $2 : '';	# keep -w happy
	$Prefix  = defined($3) ? $3 : '';	# keep -w happy
	($Module_cname = $Module) =~ s/\W/_/g;
	($Packid = $Package) =~ tr/:/_/;
	$Packprefix = $Package;
	$Packprefix .= "::" if $Packprefix ne "";
	$lastline = "";
    }

    for(;;) {
	if ($lastline !~ /^\s*#/ ||
	    $lastline =~ /^#[ \t]*(?:(?:if|ifn?def|else|elif|endif|define|undef|pragma)\b|include\s*["<].*[>"])/) {
	    last if $lastline =~ /^\S/ && @line && $line[-1] eq "";
	    push(@line, $lastline);
	    push(@line_no, $lastline_no) ;
	}

	# Read next line and continuation lines
	last unless defined($lastline = <F>);
	$lastline_no = $.;
	my $tmp_line;
	$lastline .= $tmp_line
	    while ($lastline =~ /\\$/ && defined($tmp_line = <F>));
	    
	chomp $lastline;
	$lastline =~ s/^\s+$//;
    }
    pop(@line), pop(@line_no) while @line && $line[-1] eq "";
    1;
}

PARAGRAPH:
while (fetch_para()) {
    # Print initial preprocessor statements and blank lines
    print shift(@line), "\n"
	while @line && $line[0] !~ /^[^\#]/;

    next PARAGRAPH unless @line;

    death ("Code is not inside a function")
	if $line[0] =~ /^\s/;

    # initialize info arrays
    undef(%args_match);
    undef(%var_types);
    undef(%var_addr);
    undef(%defaults);
    undef($class);
    undef($static);
    undef($elipsis);
    undef($wantRETVAL) ;
    undef(%arg_list) ;

    $_ = shift(@line);
    if (check_keyword("REQUIRE")) {
        REQUIRE_handler() ; 
        next PARAGRAPH unless @line ;
        $_ = shift(@line);
    }

    if (check_keyword("BOOT")) {
	&check_cpp;
        push (@BootCode, $_, @line, "") ;
        next PARAGRAPH ;
    }


    # extract return type, function name and arguments
    my($ret_type) = TidyType($_);

    # a function definition needs at least 2 lines
    blurt ("Error: Function definition too short '$ret_type'"), next PARAGRAPH
	unless @line ;

    $static = 1 if $ret_type =~ s/^static\s+//;

    $func_header = shift(@line);
    blurt ("Error: Cannot parse function definition from '$func_header'"), next PARAGRAPH
	unless $func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*$/s;

    ($class, $func_name, $orig_args) =  ($1, $2, $3) ;
    ($pname = $func_name) =~ s/^($Prefix)?/$Packprefix/;

    # Check for duplicate function definition
    if (defined $Func_name{"${Packid}_$func_name"} ) {
       Warn("Warning: duplicate function definition '$func_name' detected") 
    }
    else {
        push(@Func_name, "${Packid}_$func_name");
        push(@Func_pname, $pname);
    }
    $Func_name{"${Packid}_$func_name"} ++ ;

    @args = split(/\s*,\s*/, $orig_args);
    if (defined($class)) {
	my $arg0 = (defined($static) ? "CLASS" : "THIS");
	unshift(@args, $arg0);
	($orig_args = "$arg0, $orig_args") =~ s/^$arg0, $/$arg0/;
    }
    $orig_args =~ s/"/\\"/g;
    $min_args = $num_args = @args;
    foreach $i (0..$num_args-1) {
	    if ($args[$i] =~ s/\.\.\.//) {
		    $elipsis = 1;
		    $min_args--;
		    if ($args[$i] eq '' && $i == $num_args - 1) {
			pop(@args);
			last;
		    }
	    }
	    if ($args[$i] =~ /^([^=]*[^\s=])\s*=\s*(.*)/s) {
		    $min_args--;
		    $args[$i] = $1;
		    $defaults{$args[$i]} = $2;
		    $defaults{$args[$i]} =~ s/"/\\"/g;
	    }
    }
    if (defined($class)) {
	    $func_args = join(", ", @args[1..$#args]);
    } else {
	    $func_args = join(", ", @args);
    }
    @args_match{@args} = 1..@args;

    $PPCODE = grep(/^\s*PPCODE\s*:/, @line);
    $ALIAS  = grep(/^\s*ALIAS\s*:/,  @line);

    # print function header
    print Q<<"EOF";
#XS(XS_${Packid}_$func_name)
#[[
#    dXSARGS;
EOF
    print Q<<"EOF" if $ALIAS ;
#    dXSI32;
EOF
    if ($elipsis) {
	$cond = ($min_args ? qq(items < $min_args) : 0);
    }
    elsif ($min_args == $num_args) {
	$cond = qq(items != $min_args);
    }
    else {
	$cond = qq(items < $min_args || items > $num_args);
    }

    print Q<<"EOF" if $except;
#    char errbuf[1024];
#    *errbuf = '\0';
EOF

    if ($ALIAS) 
      { print Q<<"EOF" if $cond }
#    if ($cond)
#       croak("Usage: %s($orig_args)", GvNAME(CvGV(cv)));
EOF
    else 
      { print Q<<"EOF" if $cond }
#    if ($cond)
#	croak("Usage: $pname($orig_args)");
EOF

    print Q<<"EOF" if $PPCODE;
#    SP -= items;
EOF

    # Now do a block of some sort.

    $condnum = 0;
    $cond = '';			# last CASE: condidional
    push(@line, "$END:");
    push(@line_no, $line_no[-1]);
    $_ = '';
    &check_cpp;
    while (@line) {
	&CASE_handler if check_keyword("CASE");
	print Q<<"EOF";
#   $except [[
EOF

	# do initialization of input variables
	$thisdone = 0;
	$retvaldone = 0;
	$deferred = "";
	%arg_list = () ;
        $gotRETVAL = 0;

	&INPUT_handler;
	my $kwd;
	while ($kwd = check_keyword("INPUT|PREINIT")) {
	    if ($kwd eq 'PREINIT') { &print_section; } else { &INPUT_handler; }
	}
	if (!$thisdone && defined($class)) {
	    if (defined($static)) {
		print "\tchar *";
		$var_types{"CLASS"} = "char *";
		&generate_init("char *", 1, "CLASS");
	    }
	    else {
		print "\t$class *";
		$var_types{"THIS"} = "$class *";
		&generate_init("$class *", 1, "THIS");
	    }
	}

	# do code
	if (/^\s*NOT_IMPLEMENTED_YET/) {
		print "\ncroak(\"$pname: not implemented yet\");\n";
	} else {
		if ($ret_type ne "void") {
			print "\t" . &map_type($ret_type) . "\tRETVAL;\n"
				if !$retvaldone;
			$args_match{"RETVAL"} = 0;
			$var_types{"RETVAL"} = $ret_type;
		}
		print $deferred;
                while ($kwd = check_keyword("INIT|ALIAS")) {
                    if ($kwd eq 'INIT') {
                        &print_section
                    }
                    else {
                        ALIAS_handler
                    }
                }

		if (check_keyword("PPCODE")) {
			&print_section;
			death ("PPCODE must be last thing") if @line;
			print "\tPUTBACK;\n\treturn;\n";
		} elsif (check_keyword("CODE")) {
			&print_section;
		} elsif ($func_name eq "DESTROY") {
			print "\n\t";
			print "delete THIS;\n";
		} else {
			print "\n\t";
			if ($ret_type ne "void") {
				print "RETVAL = ";
				$wantRETVAL = 1;
			}
			if (defined($static)) {
			    if ($func_name =~ /^new/) {
				$func_name = "$class";
			    } else {
				print "${class}::";
			    }
			} elsif (defined($class)) {
				print "THIS->";
			}
			$func_name =~ s/^($spat)//
			    if defined($spat);
			print "$func_name($func_args);\n";
		}
	}

	# do output variables
	$gotRETVAL = 0;
	undef $RETVAL_code ;
	undef %outargs ;
	&OUTPUT_handler while check_keyword("OUTPUT");

	# all OUTPUT done, so now push the return value on the stack
	if ($gotRETVAL && $RETVAL_code) {
	    print "\t$RETVAL_code\n";
	} elsif ($gotRETVAL || $wantRETVAL) {
	    &generate_output($ret_type, 0, 'RETVAL');
	}

	# do cleanup
	&print_section while check_keyword("CLEANUP");

	# print function trailer
	print Q<<EOF;
#    ]]
EOF
	print Q<<EOF if $except;
#    BEGHANDLERS
#    CATCHALL
#	sprintf(errbuf, "%s: %s\\tpropagated", Xname, Xreason);
#    ENDHANDLERS
EOF
	if (check_keyword("CASE")) {
	    blurt ("Error: No `CASE:' at top of function")
		unless $condnum;
	    $_ = "CASE: $_";	# Restore CASE: label
	    next;
	}
	last if $_ eq "$END:";
	death(/^$BLOCK_re/o ? "Misplaced `$1:'" : "Junk at end of function");
    }

    print Q<<EOF if $except;
#    if (errbuf[0])
#	croak(errbuf);
EOF

    print Q<<EOF unless $PPCODE;
#    XSRETURN(1);
EOF

    print Q<<EOF;
#]]
#
EOF
}

# print initialization routine
print qq/extern "C"\n/ if $cplusplus;
print Q<<"EOF";
#XS(boot_$Module_cname)
#[[
#    dXSARGS;
#    char* file = __FILE__;
#
EOF

print Q<<"EOF" if defined %XsubAliases ;
#    {
#        CV * cv ;
#
EOF

for (@Func_name) {
    $pname = shift(@Func_pname);

    if ($XsubAliases{$pname}) {
        $XsubAliases{$pname}{$pname} = 0 
		unless defined $XsubAliases{$pname}{$pname} ;
        while ( ($name, $value) = each %{$XsubAliases{$pname}}) {
            print Q<<"EOF" ;
#        cv = newXS(\"$name\", XS_$_, file);
#        XSANY.any_i32 = $value ;
EOF
        }
    }
    else {
        print "        newXS(\"$pname\", XS_$_, file);\n";
    }
}

print Q<<"EOF" if defined %XsubAliases ;
#    }
EOF

if (@BootCode)
{
    print "\n    /* Initialisation Section */\n" ;
    print grep (s/$/\n/, @BootCode) ;
    print "\n    /* End of Initialisation Section */\n\n" ;
}

print Q<<"EOF";;
#    ST(0) = &sv_yes;
#    XSRETURN(1);
#]]
EOF

&Exit;


sub output_init {
    local($type, $num, $init) = @_;
    local($arg) = "ST(" . ($num - 1) . ")";

    eval qq/print " $init\\\n"/;
}

sub Warn
{
    # work out the line number
    my $line_no = $line_no[@line_no - @line -1] ;
 
    print STDERR "@_ in $filename, line $line_no\n" ;
}

sub blurt 
{ 
    Warn @_ ;
    $errors ++ 
}

sub death
{
    Warn @_ ;
    exit 1 ;
}

sub generate_init {
    local($type, $num, $var) = @_;
    local($arg) = "ST(" . ($num - 1) . ")";
    local($argoff) = $num - 1;
    local($ntype);
    local($tk);

    $type = TidyType($type) ;
    blurt("Error: '$type' not in typemap"), return 
	unless defined($type_kind{$type});

    ($ntype = $type) =~ s/\s*\*/Ptr/g;
    ($subtype = $ntype) =~ s/(?:Array)?(?:Ptr)?$//;
    $tk = $type_kind{$type};
    $tk =~ s/OBJ$/REF/ if $func_name =~ /DESTROY$/;
    $type =~ tr/:/_/;
    blurt("Error: No INPUT definition for type '$type' found"), return
        unless defined $input_expr{$tk} ;
    $expr = $input_expr{$tk};
    if ($expr =~ /DO_ARRAY_ELEM/) {
        blurt("Error: '$subtype' not in typemap"), return 
	    unless defined($type_kind{$subtype});
        blurt("Error: No INPUT definition for type '$subtype' found"), return
            unless defined $input_expr{$type_kind{$subtype}} ;
	$subexpr = $input_expr{$type_kind{$subtype}};
	$subexpr =~ s/ntype/subtype/g;
	$subexpr =~ s/\$arg/ST(ix_$var)/g;
	$subexpr =~ s/\n\t/\n\t\t/g;
	$subexpr =~ s/is not of (.*")/[arg %d] is not of $1, ix_$var + 1/g;
	$subexpr =~ s/\$var/${var}[ix_$var - $argoff]/;
	$expr =~ s/DO_ARRAY_ELEM/$subexpr/;
    }
    if (defined($defaults{$var})) {
	    $expr =~ s/(\t+)/$1    /g;
	    $expr =~ s/        /\t/g;
	    eval qq/print "\\t$var;\\n"/;
	    $deferred .= eval qq/"\\n\\tif (items < $num)\\n\\t    $var = $defaults{$var};\\n\\telse {\\n$expr;\\n\\t}\\n"/;
    } elsif ($expr !~ /^\t\$var =/) {
	    eval qq/print "\\t$var;\\n"/;
	    $deferred .= eval qq/"\\n$expr;\\n"/;
    } else {
	    eval qq/print "$expr;\\n"/;
    }
}

sub generate_output {
    local($type, $num, $var) = @_;
    local($arg) = "ST(" . ($num - ($num != 0)) . ")";
    local($argoff) = $num - 1;
    local($ntype);

    $type = TidyType($type) ;
    if ($type =~ /^array\(([^,]*),(.*)\)/) {
	    print "\tsv_setpvn($arg, (char *)$var, $2 * sizeof($1)), XFree((char *)$var);\n";
    } else {
	    blurt("Error: '$type' not in typemap"), return
		unless defined($type_kind{$type});
            blurt("Error: No OUTPUT definition for type '$type' found"), return
                unless defined $output_expr{$type_kind{$type}} ;
	    ($ntype = $type) =~ s/\s*\*/Ptr/g;
	    $ntype =~ s/\(\)//g;
	    ($subtype = $ntype) =~ s/(?:Array)?(?:Ptr)?$//;
	    $expr = $output_expr{$type_kind{$type}};
	    if ($expr =~ /DO_ARRAY_ELEM/) {
	        blurt("Error: '$subtype' not in typemap"), return
		    unless defined($type_kind{$subtype});
                blurt("Error: No OUTPUT definition for type '$subtype' found"), return
                    unless defined $output_expr{$type_kind{$subtype}} ;
		$subexpr = $output_expr{$type_kind{$subtype}};
		$subexpr =~ s/ntype/subtype/g;
		$subexpr =~ s/\$arg/ST(ix_$var)/g;
		$subexpr =~ s/\$var/${var}[ix_$var]/g;
		$subexpr =~ s/\n\t/\n\t\t/g;
		$expr =~ s/DO_ARRAY_ELEM\n/$subexpr/;
		eval "print qq\a$expr\a";
	    }
	    elsif ($var eq 'RETVAL') {
		if ($expr =~ /^\t\$arg = /) {
		    eval "print qq\a$expr\a";
		    print "\tsv_2mortal(ST(0));\n";
		}
		else {
		    print "\tST(0) = sv_newmortal();\n";
		    eval "print qq\a$expr\a";
		}
	    }
	    elsif ($arg =~ /^ST\(\d+\)$/) {
		eval "print qq\a$expr\a";
	    }
    }
}

sub map_type {
    my($type) = @_;

    $type =~ tr/:/_/;
    $type =~ s/^array\(([^,]*),(.*)\).*/$1 */s;
    $type;
}


sub Exit {
# If this is VMS, the exit status has meaning to the shell, so we
# use a predictable value (SS$_Abort) rather than an arbitrary
# number.
    exit ($Is_VMS ? 44 : $errors) ;
}
